

/*
MAVLink protocol implementation (auto-generated by mavgen.py)

Note: this file has been auto-generated. DO NOT EDIT
*/

using System;
using System.Collections;
using System.Collections.Generic;
    
namespace MavLink
{
    public static class MavlinkSettings
    {
		public const string WireProtocolVersion = "1.0";
		public const byte ProtocolMarker = 0xfe;
		public const bool CrcExtra = true;
		public const bool IsLittleEndian = true;
    }
    
    public delegate MavlinkMessage MavlinkPacketDeserializeFunc(byte[] bytes, int offset);

    //returns the message ID, offset is advanced by the number of bytes used to serialize
    public delegate int MavlinkPacketSerializeFunc(byte[] bytes, ref int offset, object mavlinkPacket);
 
    public class MavPacketInfo
    {
        public MavlinkPacketDeserializeFunc Deserializer;
        public int [] OrderMap;
        public byte CrcExtra;

         public MavPacketInfo(MavlinkPacketDeserializeFunc deserializer, byte crcExtra)
         {
             this.Deserializer = deserializer;
             this.CrcExtra = crcExtra;
         }
    }
 
    public static class MavLinkSerializer
    {
        public static void SetDataIsLittleEndian(bool isLittle)
        {
            bitconverter.SetDataIsLittleEndian(isLittle);
        }
    
        private static readonly FrameworkBitConverter bitconverter = new FrameworkBitConverter(); 
    
        public static Dictionary<int, MavPacketInfo> Lookup = new Dictionary<int, MavPacketInfo>
        {
			{0, new MavPacketInfo(Deserialize_TEST_TYPES, 103)},
		};

		internal static MavlinkMessage Deserialize_TEST_TYPES(byte[] bytes, int offset)
		{
			return new Msg_test_types
			{
				u64 = bitconverter.ToUInt64(bytes, offset + 0),
				s64 = bitconverter.ToInt64(bytes, offset + 8),
				d = bitconverter.ToDouble(bytes, offset + 16),
				u64_array =  ByteArrayUtil.ToUInt64(bytes, offset + 24, 3),
				s64_array =  ByteArrayUtil.ToInt64(bytes, offset + 27, 3),
				d_array =  ByteArrayUtil.ToDouble(bytes, offset + 30, 3),
				u32 = bitconverter.ToUInt32(bytes, offset + 33),
				s32 = bitconverter.ToInt32(bytes, offset + 37),
				f = bitconverter.ToSingle(bytes, offset + 41),
				u32_array =  ByteArrayUtil.ToUInt32(bytes, offset + 45, 3),
				s32_array =  ByteArrayUtil.ToInt32(bytes, offset + 48, 3),
				f_array =  ByteArrayUtil.ToSingle(bytes, offset + 51, 3),
				u16 = bitconverter.ToUInt16(bytes, offset + 54),
				s16 = bitconverter.ToInt16(bytes, offset + 56),
				u16_array =  ByteArrayUtil.ToUInt16(bytes, offset + 58, 3),
				s16_array =  ByteArrayUtil.ToInt16(bytes, offset + 61, 3),
				c = bytes[offset + 64],
				s =  ByteArrayUtil.ToChar(bytes, offset + 65, 10),
				u8 = bytes[offset + 75],
				s8 = bitconverter.ToInt8(bytes, offset + 76),
				u8_array =  ByteArrayUtil.ToUInt8(bytes, offset + 77, 3),
				s8_array =  ByteArrayUtil.ToInt8(bytes, offset + 80, 3),
			};
		}

		internal static int Serialize_TEST_TYPES(this Msg_test_types msg, byte[] bytes, ref int offset)
		{
			bitconverter.GetBytes(msg.u64, bytes, offset + 0);
			bitconverter.GetBytes(msg.s64, bytes, offset + 8);
			bitconverter.GetBytes(msg.d, bytes, offset + 16);
			ByteArrayUtil.ToByteArray(msg.u64_array, bytes, offset + 24, 3);
			ByteArrayUtil.ToByteArray(msg.s64_array, bytes, offset + 48, 3);
			ByteArrayUtil.ToByteArray(msg.d_array, bytes, offset + 72, 3);
			bitconverter.GetBytes(msg.u32, bytes, offset + 96);
			bitconverter.GetBytes(msg.s32, bytes, offset + 100);
			bitconverter.GetBytes(msg.f, bytes, offset + 104);
			ByteArrayUtil.ToByteArray(msg.u32_array, bytes, offset + 108, 3);
			ByteArrayUtil.ToByteArray(msg.s32_array, bytes, offset + 120, 3);
			ByteArrayUtil.ToByteArray(msg.f_array, bytes, offset + 132, 3);
			bitconverter.GetBytes(msg.u16, bytes, offset + 144);
			bitconverter.GetBytes(msg.s16, bytes, offset + 146);
			ByteArrayUtil.ToByteArray(msg.u16_array, bytes, offset + 148, 3);
			ByteArrayUtil.ToByteArray(msg.s16_array, bytes, offset + 154, 3);
			bytes[offset + 160] = msg.c; // todo: check int8_t and char are compatible
			ByteArrayUtil.ToByteArray(msg.s, bytes, offset + 161, 10);
			bytes[offset + 171] = msg.u8;
			bytes[offset + 172] = unchecked((byte)msg.s8);
			ByteArrayUtil.ToByteArray(msg.u8_array, bytes, offset + 173, 3);
			ByteArrayUtil.ToByteArray(msg.s8_array, bytes, offset + 176, 3);
			offset += 179;
			return 0;
		}
	}

}

